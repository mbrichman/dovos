require 'octokit'
require 'date'
require 'optparse'
require 'terminal-table'
require 'csv'

class TeamCycleTimeCalculator
  def initialize(options)
    @org = options[:org]
    @team_slug = options[:team]
    @token = options[:token]
    @target_branch = options[:target_branch] || 'main'
    @days = options[:days] || 30
    @output_dir = options[:output] || '.'
    
    # Create client with appropriate authentication
    @client = Octokit::Client.new(access_token: @token)
    @client.auto_paginate = true
    
    # Track all cycle times across repositories
    @all_cycle_times = []
    @repo_errors = []
  end

  def run
    # Get all repositories for the team
    begin
      team_repos = get_team_repositories
      
      if team_repos.empty?
        puts "No repositories found for team '#{@team_slug}' in organization '#{@org}'."
        puts "Please verify the team slug and organization name are correct and your token has sufficient permissions."
        exit 1
      end
      
      puts "Found #{team_repos.size} repositories for team '#{@team_slug}' in '#{@org}':"
      team_repos.each { |repo| puts "  - #{repo.full_name}" }
      puts
      
    rescue Octokit::NotFound
      puts "Error: Team or organization not found."
      puts "Please check:"
      puts "  1. The organization name '#{@org}' is correct"
      puts "  2. The team slug '#{@team_slug}' is correct"
      puts "  3. Your token has access to this organization and team"
      exit 1
    rescue => e
      puts "Error retrieving repositories: #{e.message}"
      exit 1
    end
    
    # Process each repository
    team_repos.each do |repo|
      process_repository(repo.full_name)
    end
    
    # Display summary results across all repositories
    display_summary_results
    
    # Report any errors
    if @repo_errors.any?
      puts "\nThe following repositories had errors:"
      @repo_errors.each do |error|
        puts "  - #{error[:repo]}: #{error[:message]}"
      end
    end
  end

  private
  
  def get_team_repositories
    puts "Fetching repositories for team '#{@team_slug}' in organization '#{@org}'..."
    @client.team_repositories("#{@org}/#{@team_slug}")
  end
  
  def process_repository(repo_name)
    puts "\n======================================================="
    puts "Processing repository: #{repo_name}"
    puts "======================================================="
    
    begin
      # Verify repository exists and is accessible
      repo_info = @client.repository(repo_name)
      puts "Repository: #{repo_name} (#{repo_info.visibility})"
      puts "Target branch: #{@target_branch}"
      puts "Analyzing PRs merged in the last #{@days} days"
      
      # Try to get the merged PRs
      merged_prs = get_merged_prs(repo_name)
      
      if merged_prs.empty?
        puts "No merged PRs found for repository #{repo_name} in the last #{@days} days."
        return
      end
      
      # Calculate cycle times for this repository
      cycle_times = calculate_cycle_times(repo_name, merged_prs)
      
      # Add repository name to each cycle time entry
      cycle_times.each { |ct| ct[:repository] = repo_name }
      
      # Add to the overall list
      @all_cycle_times.concat(cycle_times)
      
      # Display results for this repository
      display_repo_results(repo_name, cycle_times)
      
    rescue Octokit::NotFound
      puts "Repository '#{repo_name}' not found or not accessible with your token."
      @repo_errors << { repo: repo_name, message: "Not found or not accessible" }
    rescue => e
      puts "Error processing repository '#{repo_name}': #{e.message}"
      @repo_errors << { repo: repo_name, message: e.message }
    end
  end

  def get_merged_prs(repo_name)
    cutoff_date = (Date.today - @days).to_time
    
    puts "Fetching merged pull requests..."
    
    begin
      prs = @client.pull_requests(repo_name, state: 'closed')
    rescue Octokit::UnprocessableEntity
      # Try an alternative approach if the above fails
      puts "Using alternative method to fetch PRs..."
      prs = @client.pulls(repo_name, state: 'closed')
    end
    
    # Filter to only include PRs that were merged to the target branch within the timeframe
    merged_prs = prs.select do |pr|
      pr.merged_at && 
      pr.merged_at > cutoff_date && 
      (pr.base.ref == @target_branch || @target_branch == 'all')
    end
    
    puts "Found #{merged_prs.size} PRs merged to #{@target_branch == 'all' ? 'any branch' : @target_branch} in the last #{@days} days"
    merged_prs
  end

  def calculate_cycle_times(repo_name, prs)
    cycle_times = []
    error_count = 0
    
    prs.each do |pr|
      pr_number = pr.number
      print "Analyzing PR ##{pr_number}... "
      
      begin
        # Get commits for this PR
        commits = @client.pull_request_commits(repo_name, pr_number)
        
        if commits.empty?
          puts "No commits found, skipping"
          next
        end
        
        # Get the earliest commit date
        first_commit_date = commits.map { |commit| commit.commit.author.date }.min
        merge_date = pr.merged_at
        
        # Calculate cycle time in hours
        cycle_time_hours = ((merge_date - first_commit_date) / 3600).round(2)
        
        # Get the developer who created the PR
        author = pr.user.login
        
        # Get the target branch
        target_branch = pr.base.ref
        
        cycle_times << {
          repository: repo_name,
          pr_number: pr_number,
          title: pr.title,
          first_commit: first_commit_date,
          merged_at: merge_date,
          cycle_time_hours: cycle_time_hours,
          cycle_time_days: (cycle_time_hours / 24).round(2),
          author: author,
          target_branch: target_branch
        }
        puts "Done (#{cycle_time_hours.round(2)} hours)"
      rescue => e
        puts "Error: #{e.message}"
        error_count += 1
      end
    end
    
    puts "Completed analysis with #{error_count} errors" if error_count > 0
    cycle_times
  end

  def display_repo_results(repo_name, cycle_times)
    return puts "No data available for analysis" if cycle_times.empty?
    
    # Calculate statistics
    hours = cycle_times.map { |ct| ct[:cycle_time_hours] }
    avg_hours = hours.sum / hours.size
    median_hours = hours.sort[hours.size / 2]
    
    # Print summary
    puts "\nCycle Time Summary for #{repo_name}:"
    puts "-------------------"
    puts "Total PRs analyzed: #{cycle_times.size}"
    puts "Average cycle time: #{avg_hours.round(2)} hours (#{(avg_hours / 24).round(2)} days)"
    puts "Median cycle time: #{median_hours.round(2)} hours (#{(median_hours / 24).round(2)} days)"
    puts "Min cycle time: #{hours.min.round(2)} hours (#{(hours.min / 24).round(2)} days)"
    puts "Max cycle time: #{hours.max.round(2)} hours (#{(hours.max / 24).round(2)} days)"
    
    # Print detailed table
    table = Terminal::Table.new(
      headings: ['PR #', 'Title', 'Author', 'Target Branch', 'First Commit', 'Merged At', 'Cycle Time (hours)', 'Cycle Time (days)'],
      rows: cycle_times.map do |ct|
        [
          ct[:pr_number],
          ct[:title].length > 30 ? "#{ct[:title][0..27]}..." : ct[:title],
          ct[:author],
          ct[:target_branch],
          ct[:first_commit].strftime('%Y-%m-%d %H:%M'),
          ct[:merged_at].strftime('%Y-%m-%d %H:%M'),
          ct[:cycle_time_hours],
          ct[:cycle_time_days]
        ]
      end
    )
    
    puts "\nDetailed Results:"
    puts table
    
    # Save results to CSV
    save_repo_to_csv(repo_name, cycle_times)
  end
  
  def save_repo_to_csv(repo_name, cycle_times)
    # Create output directory if it doesn't exist
    Dir.mkdir(@output_dir) unless Dir.exist?(@output_dir)
    
    # Create a safe filename
    safe_repo_name = repo_name.gsub('/', '_')
    filename = "#{@output_dir}/cycle_time_#{safe_repo_name}_#{Date.today}.csv"
    
    CSV.open(filename, 'wb') do |csv|
      csv << ['Repository', 'PR #', 'Title', 'Author', 'Target Branch', 'First Commit', 'Merged At', 'Cycle Time (hours)', 'Cycle Time (days)']
      
      cycle_times.each do |ct|
        csv << [
          ct[:repository],
          ct[:pr_number],
          ct[:title],
          ct[:author],
          ct[:target_branch],
          ct[:first_commit].strftime('%Y-%m-%d %H:%M'),
          ct[:merged_at].strftime('%Y-%m-%d %H:%M'),
          ct[:cycle_time_hours],
          ct[:cycle_time_days]
        ]
      end
    end
    
    puts "\nResults for #{repo_name} saved to #{filename}"
  end
  
  def display_summary_results
    return puts "\nNo data available for team-wide analysis" if @all_cycle_times.empty?
    
    puts "\n======================================================="
    puts "TEAM-WIDE SUMMARY"
    puts "======================================================="
    
    # Calculate overall statistics
    hours = @all_cycle_times.map { |ct| ct[:cycle_time_hours] }
    avg_hours = hours.sum / hours.size
    median_hours = hours.sort[hours.size / 2]
    
    # Statistics by repository
    repos = @all_cycle_times.group_by { |ct| ct[:repository] }
    repo_stats = repos.map do |repo, times|
      repo_hours = times.map { |t| t[:cycle_time_hours] }
      {
        repository: repo,
        pr_count: times.size,
        avg_hours: (repo_hours.sum / repo_hours.size).round(2),
        median_hours: repo_hours.sort[repo_hours.size / 2].round(2)
      }
    end
    
    # Statistics by author
    authors = @all_cycle_times.group_by { |ct| ct[:author] }
    author_stats = authors.map do |author, times|
      author_hours = times.map { |t| t[:cycle_time_hours] }
      {
        author: author,
        pr_count: times.size,
        avg_hours: (author_hours.sum / author_hours.size).round(2),
        median_hours: author_hours.sort[author_hours.size / 2].round(2)
      }
    end
    
    # Print overall summary
    puts "\nTeam Cycle Time Summary:"
    puts "------------------------"
    puts "Total repositories analyzed: #{repos.size}"
    puts "Total PRs analyzed: #{@all_cycle_times.size}"
    puts "Average cycle time: #{avg_hours.round(2)} hours (#{(avg_hours / 24).round(2)} days)"
    puts "Median cycle time: #{median_hours.round(2)} hours (#{(median_hours / 24).round(2)} days)"
    puts "Min cycle time: #{hours.min.round(2)} hours (#{(hours.min / 24).round(2)} days)"
    puts "Max cycle time: #{hours.max.round(2)} hours (#{(hours.max / 24).round(2)} days)"
    
    # Print repository summary
    puts "\nRepository Summary:"
    repo_table = Terminal::Table.new(
      headings: ['Repository', 'PR Count', 'Avg Cycle Time (hours)', 'Median Cycle Time (hours)'],
      rows: repo_stats.sort_by { |r| r[:avg_hours] }.map do |rs|
        [rs[:repository], rs[:pr_count], rs[:avg_hours], rs[:median_hours]]
      end
    )
    puts repo_table
    
    # Print author summary
    puts "\nAuthor Summary:"
    author_table = Terminal::Table.new(
      headings: ['Author', 'PR Count', 'Avg Cycle Time (hours)', 'Median Cycle Time (hours)'],
      rows: author_stats.sort_by { |a| a[:avg_hours] }.map do |as|
        [as[:author], as[:pr_count], as[:avg_hours], as[:median_hours]]
      end
    )
    puts author_table
    
    # Save team-wide results
    save_team_to_csv
  end
  
  def save_team_to_csv
    # Create output directory if it doesn't exist
    Dir.mkdir(@output_dir) unless Dir.exist?(@output_dir)
    
    # Overall results
    filename = "#{@output_dir}/team_cycle_time_#{@org}_#{@team_slug}_#{Date.today}.csv"
    
    CSV.open(filename, 'wb') do |csv|
      csv << ['Repository', 'PR #', 'Title', 'Author', 'Target Branch', 'First Commit', 'Merged At', 'Cycle Time (hours)', 'Cycle Time (days)']
      
      @all_cycle_times.each do |ct|
        csv << [
          ct[:repository],
          ct[:pr_number],
          ct[:title],
          ct[:author],
          ct[:target_branch],
          ct[:first_commit].strftime('%Y-%m-%d %H:%M'),
          ct[:merged_at].strftime('%Y-%m-%d %H:%M'),
          ct[:cycle_time_hours],
          ct[:cycle_time_days]
        ]
      end
    end
    
    puts "\nTeam-wide results saved to #{filename}"
  end
end

# Parse command line options
options = {}
parser = OptionParser.new do |opts|
  opts.banner = "Usage: team_cycle_time.rb [options]"

  opts.on("-o", "--org ORGANIZATION", "GitHub organization name") do |org|
    options[:org] = org
  end

  opts.on("-m", "--team TEAM_SLUG", "GitHub team slug") do |team|
    options[:team] = team
  end

  opts.on("-t", "--token TOKEN", "GitHub API token") do |token|
    options[:token] = token
  end

  opts.on("-b", "--branch BRANCH", "Target branch (default: main, use 'all' for all branches)") do |branch|
    options[:target_branch] = branch
  end

  opts

  opts.on("-d", "--days DAYS", Integer, "Number of days to analyze (default: 30)") do |days|
    options[:days] = days
  end
  
  opts.on("-u", "--output OUTPUT_DIR", "Output directory for CSV files (default: current directory)") do |dir|
    options[:output] = dir
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end

begin
  parser.parse!
  
  # Check required options
  missing_options = []
  missing_options << "organization (-o)" unless options[:org]
  missing_options << "team (-m)" unless options[:team]
  missing_options << "token (-t)" unless options[:token]
  
  if missing_options.any?
    puts "Error: Missing required options: #{missing_options.join(', ')}"
    puts parser
    exit 1
  end
  
  # Run the calculator
  TeamCycleTimeCalculator.new(options).run
  
rescue OptionParser::InvalidOption => e
  puts e
  puts parser
  exit 1
rescue => e
  puts "Unexpected error: #{e.message}"
  puts e.backtrace.join("\n")
  exit 1
end