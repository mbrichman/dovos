#!/usr/bin/env ruby

# Ensure we're using the correct Ruby version
if ENV['RBENV_VERSION'].nil?
  # Get the desired Ruby version from .ruby-version file (if it exists)
  ruby_version_file = File.join(File.dirname(__FILE__), '.ruby-version')
  desired_version = File.read(ruby_version_file).strip if File.exist?(ruby_version_file)
  
  # If we're not using the right version, re-execute with rbenv
  if desired_version && `which ruby`.chomp != "/Users/#{ENV['USER']}/.rbenv/versions/#{desired_version}/bin/ruby"
    ENV['RBENV_VERSION'] = desired_version
    exec('/Users/' + ENV['USER'] + '/.rbenv/shims/ruby', __FILE__, *ARGV)
  end
end

require 'json'
require 'rest_client'
require 'uri'
require 'dotenv'
require 'pry'
require 'bundler/setup'

class ConversationDMSConnector
  def initialize(dms_config: {})
    @stdin = $stdin
    @stdout = $stdout
    @stderr = $stderr
    @dms_config = dms_config
    @auth_token = nil
  end
  
  def start
    @stdin.each_line do |line|
      begin
        request = JSON.parse(line.strip)
        response = handle_request(request)
        
        if response
          @stdout.puts(JSON.generate(response))
          @stdout.flush
        end
      rescue JSON::ParserError => e
        @stderr.puts "Error parsing request: #{e.message}"
      rescue => e
        @stderr.puts "Error handling request: #{e.class} - #{e.message}"
      end
    end
  end
  
  private
  
  def get_auth_token
    # Return cached token if available and not expired
    return @auth_token if @auth_token && !token_expired?
    
    begin
      response = RestClient.post(
        'https://cloudimanage.com/auth/oauth2/token',
        {
          username: @dms_config[:username],
          password: @dms_config[:password],
          grant_type: 'password',
          client_id: @dms_config[:client_id],
          client_secret: @dms_config[:client_secret]
        },
        content_type: 'application/x-www-form-urlencoded',
        'X-Auth-Token' => @dms_config[:x_auth_token]
      )
      
      result = JSON.parse(response.body)
      @auth_token = result['access_token']
      @token_expiry = Time.now + result['expires_in'] if result['expires_in']
      # binding.pry
      @auth_token
    rescue RestClient::ExceptionWithResponse => e
      @stderr.puts "Failed to get auth token: #{e.response.body}"
      nil
    rescue => e
      @stderr.puts "Error getting auth token: #{e.message}"
      nil
    end
  end
  
  def token_expired?
    # return true unless @token_expiry
    # Time.now >= @token_expiry
    false
  end
  
  def save_to_dms(conversation:, title:, metadata:)
    # Get auth token
    token = get_auth_token
    return { success: false, error: "Failed to get authentication token" } unless token
    
    # Format conversation as markdown
    document_content = format_conversation(conversation)
    
    # Create temporary file for upload
    require 'tempfile'
    temp_file = Tempfile.new(['conversation', '.md'])
    temp_file.write(document_content)
    temp_file.rewind
    
    begin
      # Build the upload URL
      upload_url = "https://cloudimanage.com/api/v2/customers/#{@dms_config[:customer_id]}/libraries/#{@dms_config[:library]}/folders/#{@dms_config[:folder_id]}/documents"
      
      # Prepare profile JSON
      profile = {
        doc_profile: {
          name: title,
          type: metadata[:type] || 'WORDX'
        },
        warnings_for_required_and_disabled_fields: true
      }
      
      # Upload document using multipart form data
      response = RestClient.post(
        upload_url,
        {
          profile: profile.to_json,
          file: File.new(temp_file.path, 'rb')
        },
        'X-Auth-Token' => token,
        content_type: :json,
        accept: :json
      )
      
      result = JSON.parse(response.body)
      { success: true, document_id: result['id'] }
    rescue RestClient::ExceptionWithResponse => e
      # Token might have expired, try refreshing once
      if e.response.code == 401
        @auth_token = nil  # Clear cached token
        return save_to_dms(conversation: conversation, title: title, metadata: metadata)
      end
      
      { success: false, error: "HTTP #{e.response.code}: #{e.response}" }
    rescue => e
      { success: false, error: e.message }
    ensure
      # Clean up temp file
      temp_file.close
      temp_file.unlink
    end
  end
  
  def format_conversation(messages)
    markdown = "# AI Conversation Archive\n\n"
    markdown += "**Generated:** #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
    markdown += "---\n\n"
    
    messages.each.with_index do |msg, idx|
      speaker = msg['role'] == 'user' ? 'Human' : 'Assistant'
      markdown += "### #{speaker} (#{idx + 1})\n\n"
      markdown += "#{msg['content']}\n\n"
      markdown += "---\n\n" unless idx == messages.length - 1
    end
    
    markdown
  end
  
  def handle_request(request)
    case request['method']
    when 'initialize'
      handle_initialize(request)
    when 'tools/call'
      handle_call_tool(request)
    when 'tools/list'
      handle_list_tools(request)
    else
      error_response(request['id'], "Method not found: #{request['method']}")
    end
  end
  
  def handle_initialize(request)
    {
      jsonrpc: '2.0',
      id: request['id'],
      result: {
        protocolVersion: '2024-11-05',
        serverInfo: {
          name: 'conversation-dms-connector',
          version: '1.0.0'
        },
        capabilities: {
          tools: {}
        }
      }
    }
  end
  
  def handle_list_tools(request)
    {
      jsonrpc: '2.0',
      id: request['id'],
      result: {
        tools: [
          {
            name: 'save-conversation',
            description: 'Save AI conversation to CloudiManage DMS',
            inputSchema: {
              type: 'object',
              properties: {
                conversation: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      role: { type: 'string' },
                      content: { type: 'string' }
                    },
                    required: ['role', 'content']
                  }
                },
                title: { type: 'string' },
                metadata: { type: 'object' }
              },
              required: ['conversation']
            }
          }
        ]
      }
    }
  end
  
  def handle_call_tool(request)
    tool_name = request.dig('params', 'name')
    args = request.dig('params', 'arguments') || {}
    
    case tool_name
    when 'save-conversation'
      result = save_to_dms(
        conversation: args['conversation'],
        title: args['title'] || "Conversation #{Time.now.strftime('%Y-%m-%d %H:%M')}",
        metadata: args['metadata'] || {}
      )
      
      {
        jsonrpc: '2.0',
        id: request['id'],
        result: {
          content: [
            {
              type: 'text',
              text: result[:success] ? 
                "Successfully saved to DMS. Document ID: #{result[:document_id]}" :
                "Failed to save: #{result[:error]}"
            }
          ]
        }
      }
    else
      error_response(request['id'], "Unknown tool: #{tool_name}")
    end
  end
  
  def error_response(id, message)
    {
      jsonrpc: '2.0',
      id: id,
      error: {
        code: -32000,
        message: message
      }
    }
  end
end

# Run the connector
if __FILE__ == $0
  # Load environment variables
  Dotenv.load
  
  connector = ConversationDMSConnector.new(
    dms_config: {
      username: ENV['DMS_USERNAME'],
      password: ENV['DMS_PASSWORD'],
      client_id: ENV['DMS_CLIENT_ID'],
      client_secret: ENV['DMS_CLIENT_SECRET'],
      x_auth_token: ENV['DMS_X_AUTH_TOKEN'],
      customer_id: ENV['DMS_CUSTOMER_ID'],
      library: ENV['DMS_LIBRARY'],
      folder_id: ENV['DMS_FOLDER_ID']
    }
  )
  connector.start
end
